= テンプレートからソースコード(Rubyスクリプト)へ
さて、後はテンプレートを編集していきます。というのは半分正解で半分不正解です。

前章でも

「"xxxx is not implemented yet."と表示されるようになっていますので自分で実装したいところから書き換えて行くイメージ」

と書きました。実際それで動きますし、Ruby-GNOME2-0.9.1までは確かにその方法が一般的（？）でした。
でも、その方法だと「機能追加などでGUIを変更したとき、hwedit_glade.rbを毎回作り直す（バックアップを取っておいてシグナルハンドラ部分を書き直す」というような「手動マージ作業」を行う必要があります。
もっと複雑なこと、たとえば自前の定数を書いてみたり、メソッドを追加してみたりするとなおさらマージ作業が大変になりますし、Ruby/Libglade2がバージョンアップしたときに自動的に追加されるメソッドが増えるかもしれません。
このように、ruby-glade-create-templateは最初の1回のテンプレート生成だけは使えるのですが、2度目以降はあまり使えないツールになってしまい、とたんに生産性が落ちてしまいます。

そこで、ここでは、hwedit_glade.rbに触れることなく別ファイルにソースコードを書いておくようにして、少しでもその辺の面倒くささを回避する方法を推奨します（Ruby-GNOME2-0.10.0以降）。


== まずはコピペ
一番最初にhwedit_glade.rbを生成したとき、これをコピーして、（この例では）hwedit.rbという名前にします。
次に、このファイルを編集します。以下に例を示します。（変更部分のみ）

  require 'hwedit_glade'
 
  class Hwedit < HweditGlade 
  #  include GetText

  #  attr :glade

冒頭を、hwedit_glade.rbを読み込んで実行しHweditGladeのサブクラスを定義する形に書き換えます。コメントアウトした部分は不要なので削除します。

    def initialize(path_or_data, root = nil, domain = nil, localedir = nil, flag = GladeXML::FILE)
      super(path_or_data, root, domain, localedir, flag)
      bindtextdomain(domain, localedir, nil, "")
    end

親クラスのinitializeを呼び出した後（super）、親クラスのinitializeで実行済みのbindtextdomainを再度呼び出しています。これは"hwedit_glade.rb"を編集せずに、地域化用データの出力時の文字コードを正しく指定するためです。上記のように文字コード名に空文字列を指定しておくと、プログラム実行時のロケールに合わせたものが自動で選択されます（MS Windowsではそのように動作しました）。文字コード無指定のbindtextdomainを実行しなかった場合、HweditGladeクラスでのbindtextdomain実行時に指定したUTF-8が有効なままになるので、たとえばMS Windowsのコンソールウィンドウに地域化用データ文字列を出力すると文字化けします。ただしGUI上に表示するだけであれば、MS WindowsでもUTF-8のままで大丈夫なようなので、必要ないと思う場合はここでのbindtextdomain呼び出しは省略してしまってもいいでしょう。

    def on_main_window_delete_event(widget, arg0)
      puts "on_main_window_delete_event"		# 必要なくなったら消す
      false
    end
    def on_main_window_destroy(widget)
      puts "on_main_window_destroy"
      Gtk.main_quit
    end

「((<プライマリ（メイン）ウィンドウを作る|libglade2-tut-mainwindow>))」のページで説明したように、プログラムのウィンドウのクローズボタンをクリックしたときに正しくプログラムを終了させるのに最低限必要な処理を書きます。（今の時点ではon_main_window_delete_eventは変更しなくても動作しますが）

※　他のシグナルハンドラもカスタマイズが必要になったときのために消さずに残しておきます。

要はinitializeとシグナルハンドラを上書きするようなサブクラスを作るわけです。
この部分だけ、きっと手間に感じると思いますが、一度作れば後は楽チンなこと間違いなしです。

  end
  
  # Main program
  if __FILE__ == $0
    # Set values as your own application. 
    PROG_PATH = "hwedit.glade"
    PROG_NAME = "hwedit"
    Hwedit.new(PROG_PATH, nil, PROG_NAME)
    Gtk.main
  end

PROG_PATHとPROG_NAMEは適切な値に書き直します。また、HweditGlade.newとなっている行もHwedit.newに変更します。

PROG_PATHはhwedit.gladeを置くPATHです。上記例ではこのツールを実行するディレクトリに置いているのでそのままにしてありますが、実際にアプリケーションとして公開する場合はちょっと考えなければなりません。
一般的にはMS Windowsであればc:\ruby\share\hwedit\glade\配下、Linux/FreeBSDであれば、/usr/share/hwedit/gladeに置けば良いでしょう。

これらの値は以下のようにすれば取得できます。

 require 'rbconfig'
 datadir = Config::CONFIG["datadir"]
 
したがって、先のPROG_PATHはこれを指定してしまうというのも一案でしょう。
私はこの辺の設定周りは別ファイル化(config.rbとか)にして、インストーラを起動するときに自動的に生成するようにしています。

PROG_NAMEは地域化用データのファイル名（拡張子を除く）として扱われます。ここではプログラム名を代入しています。

=== シグナルハンドラの実装
さて、後は気の向くままにシグナルハンドラたちを実装しましょう。@glade["textview1"]というような形でそれぞれウィジェットのインスタンスを呼び出すことができます。"textview1"はGlade-2上で設定した（あるいはデフォルトのままではウィジェット + 番号という形になる）ウィジェット名です。
ただ、いちいちそのように書くのも手間なので良く使うウィジェットはインスタンス変数に代入しておくと便利です。

例えばこんな感じです。

  def initialize(path_or_data, root = nil, domain = nil, localedir = nil, flag = GladeXML::FILE)
    super(path_or_data, root, domain, localedir, flag)
    bindtextdomain(domain, localedir, nil, "")
    
    @editor = @glade['textview1']
    @filedlg = @glade['filechooser']
    @aboutdlg = @glade['aboutdialog']
  end

{{br}}

以下、シグナルハンドラの実装例です。まずは簡単な所で、"Edit"メニューの"Cut(切り取り)"、"Copy(コピー)"、"Paste(貼り付け)"コマンドを実装してみます。

  def on_paste1_activate(widget)
    puts "on_paste1_activate"
    @editor.paste_clipboard
  end

  def on_copy1_activate(widget)
    puts "on_copy1_activate"
    @editor.copy_clipboard
  end

  def on_cut1_activate(widget)
    puts "on_cut1_activate"
    @editor.cut_clipboard
  end

以上（笑）。Gtk::TextViewのおかげです。ちなみにTextViewウィジェットの右クリック（コンテキスト）メニュー内のコマンドは実装する必要すらありません。デフォルトで動作します。

{{br}}

次は、"Help"メニューの"About"コマンドを選択した時に、Gladeで作っておいたアバウトダイアログを表示する例です。

  def on_about1_activate(widget)
    puts "on_about1_activate"
    @aboutdlg.run do |response|
      case response
      when Gtk::Dialog::RESPONSE_DELETE_EVENT
        puts "RESPONSE_DELETE_EVENT"
      when Gtk::Dialog::RESPONSE_CLOSE
        puts "RESPONSE_CLOSE"
      end
    end
    @aboutdlg.hide
  end

Gtk::Dialog#runは、ダイアログ上で何らかの"response" Signalが発生するまで待機し、Signalを受け取ると関連付けられたブロックを実行してメソッドを抜けます。"response" Signalとは、"response ID"が設定されたボタンが押されるか、またはダイアログ枠のクローズボタン（これを押したというイベントにも"response ID"が設定されています）が押された時に発生するSignalです。"response ID"はブロック引数として渡されるので、ブロック内でこの値に応じた処理を行うことができます。

コード中の定数は事前定義されたIDです。((<「Gtk2チュートリアル」の「ダイアログ」のページ|gtk2-tut-dialog>))などに一覧があります。Gtk::Dialog::RESPONSE_CLOSEはGlade上でボタンのプロパティに表示されるものと違いますが、あれをそのまま使うと、定義されていないというエラーが出てしまうので、Gtk::Dialog::RESPONSE_??の方を使うのが簡単です。個々のIDの対応はすぐわかると思います。((-"response ID"の実体は整数ですが、事前定義されたものはすべて負の整数です。もしユーザ定義のものを使う場合には正の整数にする必要があります。-))

ただアバウトダイアログの場合、"response ID"の値によって処理を分ける必要はないので、以下のようなコードで済ませてしまうのが普通です。

  def on_about1_activate(widget)
    puts "on_about1_activate"
    @aboutdlg.run
    @aboutdlg.hide
  end

Gtk::Dialog#runは、どのボタンを押してもダイアログが閉じる処理の場合には便利ですが、そうでない場合、他のウィジェットと同じ方法でシグナルハンドラを設定することもできます。詳しくは((<「Gtk2チュートリアル」の「ダイアログ」のページ|gtk2-tut-dialog>))を見て下さい。

{{br}}

もう一つ、"File"メニューの"Open(開く)"コマンドを選択した時に、Gladeで作っておいたGtk::FileChooserDialogを使って、TextViewにテキストファイルを読み込む例です。

  require 'hwedit_glade'
  require 'kconv'		# この行を追加

まず文字コード変換処理に必要なKconvモジュールを読み込むコードを冒頭に追加します。プログラムからTextViewにテキストを入力する場合、文字コードがUTF-8になっている必要があります。

  def on_open1_activate(widget)
    puts "on_open1_activate"
    if @filedlg.run == Gtk::Dialog::RESPONSE_OK
      @editor.buffer.text  = ""			# バッファをクリア
      File.open(@filedlg.filename).each do |line|	# 1行ずつ処理
        @editor.insert_at_cursor(Kconv.toutf8(line))
        # 文字コードを変換してカーソル位置(バッファ末尾)に挿入
      end
      @editor.move_cursor(Gtk::MOVEMENT_BUFFER_ENDS, -1, false)	# カーソルを先頭に移動
    end
    @filedlg.hide
  end

処理の内容はコメントの通りです。サンプルのため、以前に表示されていたテキストを保存するかどうかの確認や、読み込んだテキストの文字コードの記憶などはしていません。

アバウトダイアログと同じようにrunメソッドを使っていますが、ブロックは付けずに戻り値から"Open(開く)"ボタンが押されたかどうかを判定しています。

Gtk::TextView#move_cursorは、移動単位と移動量を指定してカーソルを移動するメソッドです。移動量はマイナス値を指定できます。3番目の引数は、移動前の位置から移動後の位置までのテキストを選択状態にするかどうかを指定します。
